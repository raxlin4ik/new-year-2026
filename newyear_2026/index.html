<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#050505" />
  <title>HE IS ALREADY HERE</title>

  <style>
    :root{
      --bg:#050505;
      --fg:#d7ffe9;
      --muted:#87bfa8;
      --green:#00ff88;
      --red:#ff2b2b;
      --amber:#ffcc66;
      --card:#0b0f0d;
      --line:#123126;

      --corruption: 0; /* 0..1 */
      --radius: 16px;
      --pad: clamp(14px, 3.6vw, 22px);

      --fs: clamp(16px, 3.9vw, 20px);
      --fs-sm: clamp(12px, 3.2vw, 14px);
      --fs-lg: clamp(20px, 5vw, 28px);
    }

    *{ box-sizing:border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 20% 0%, rgba(0,255,136,0.08), transparent 60%),
                  radial-gradient(900px 700px at 90% 20%, rgba(255,43,43,0.06), transparent 65%),
                  var(--bg);
      color: var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Courier New", monospace;
      font-size: var(--fs);
      letter-spacing: 0.2px;
      overflow-x: hidden;
      text-rendering: geometricPrecision;
    }

    /* App wrapper (CRT) */
    .app{
      min-height: 100svh;
      display:flex;
      flex-direction:column;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      position: relative;
      isolation: isolate;
    }

    /* CRT overlays: scanlines + noise */
    .app::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events:none;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.035),
          rgba(255,255,255,0.035) 1px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 4px
        );
      opacity: calc(0.18 + var(--corruption) * 0.25);
      mix-blend-mode: overlay;
      z-index: 50;
    }

    .app::after{
      content:"";
      position: fixed;
      inset: -20%;
      pointer-events:none;
      background:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,0.06), transparent 35%),
        radial-gradient(circle at 70% 60%, rgba(255,255,255,0.05), transparent 40%),
        radial-gradient(circle at 40% 80%, rgba(255,255,255,0.04), transparent 40%);
      opacity: calc(0.10 + var(--corruption) * 0.22);
      filter: blur(1px);
      animation: noiseShift 900ms steps(2,end) infinite;
      z-index: 51;
      mix-blend-mode: overlay;
    }

    @keyframes noiseShift{
      0%{ transform: translate3d(0,0,0) rotate(0deg); }
      25%{ transform: translate3d(-2%, 1%,0) rotate(0.2deg); }
      55%{ transform: translate3d(1%, -2%,0) rotate(-0.15deg); }
      100%{ transform: translate3d(0,0,0) rotate(0deg); }
    }

    /* ======== APPARITIONS (SCARY FACES ON SIDES) ======== */
    .apparitions{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 25; /* below header/cards but above background */
      overflow: hidden;
    }

    .apparition{
      position: absolute;
      top: 10%;
      width: clamp(150px, 24vw, 300px);
      height: clamp(320px, 75vh, 620px);
      opacity: calc(0.03 + var(--corruption) * 0.28);
      filter: blur(0.25px) contrast(1.25) brightness(0.85);
      mix-blend-mode: screen;
      transform: translateY(0) rotate(var(--rot)) scaleX(var(--sx));
      transform-origin: center;
      animation:
        drift 10.5s ease-in-out infinite,
        flicker 3.6s steps(2,end) infinite;
    }

    .apparition.left{
      --rot: -1.4deg;
      --sx: 1;
      left: -90px;
    }
    .apparition.right{
      --rot: 1.2deg;
      --sx: -1; /* mirror */
      right: -90px;
    }

    .apparition svg{
      width: 100%;
      height: 100%;
      display: block;
    }

    .apparition .eyes{
      transform-box: fill-box;
      transform-origin: center;
      animation: blink 6.8s infinite;
      opacity: calc(0.70 + var(--corruption) * 0.35);
    }

    @keyframes blink{
      0%, 92%, 100% { transform: scaleY(1); }
      93% { transform: scaleY(0.08); }
      95% { transform: scaleY(1); }
    }

    @keyframes drift{
      0%, 100% { transform: translateY(0) rotate(var(--rot)) scaleX(var(--sx)); }
      50% { transform: translateY(10px) rotate(calc(var(--rot) - 0.6deg)) scaleX(var(--sx)); }
    }

    @keyframes flicker{
      0%, 55% { opacity: calc(0.03 + var(--corruption) * 0.28); }
      56% { opacity: calc(0.015 + var(--corruption) * 0.18); }
      57% { opacity: calc(0.05 + var(--corruption) * 0.32); }
      100% { opacity: calc(0.03 + var(--corruption) * 0.28); }
    }

    .apparition.peek{
      opacity: calc(0.16 + var(--corruption) * 0.45);
      filter: blur(0px) contrast(1.55) brightness(1.05);
    }
    .apparition.peekStrong{
      opacity: calc(0.26 + var(--corruption) * 0.55);
      filter: blur(0px) contrast(1.75) brightness(1.15);
      animation: none;
    }

    /* mobile adjustments: keep faces visible but subtle */
    @media (max-width: 480px){
      .apparition{
        top: 14%;
        width: 140px;
        height: 320px;
      }
      .apparition.left{ left: -82px; }
      .apparition.right{ right: -82px; }
    }

    /* Top bar */
    header{
      position: sticky;
      top:0;
      z-index: 40;
      padding: var(--pad);
      display:flex;
      gap: 12px;
      align-items:center;
      justify-content: space-between;
      background: linear-gradient(to bottom, rgba(5,5,5,0.95), rgba(5,5,5,0.55));
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(18,49,38,0.6);
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:700;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      font-size: var(--fs-sm);
      color: rgba(215,255,233,0.85);
    }

    .brand .pip{
      width: 10px; height: 10px;
      background: var(--green);
      border-radius: 50%;
      box-shadow: 0 0 16px rgba(0,255,136,0.6);
      animation: pipBlink 1.2s infinite;
    }
    @keyframes pipBlink{
      0%, 60% { opacity: 0.9; }
      61%, 100% { opacity: 0.35; }
    }

    .status{
      display:flex;
      align-items:center;
      gap: 10px;
      white-space: nowrap;
    }

    .progress{
      display:flex;
      gap:6px;
      align-items:center;
    }

    .seg{
      width: 12px; height: 10px;
      border-radius: 3px;
      border: 1px solid rgba(0,255,136,0.35);
      background: rgba(0,255,136,0.06);
    }
    .seg.on{
      background: rgba(0,255,136,0.48);
      box-shadow: 0 0 10px rgba(0,255,136,0.35);
    }

    .timer{
      font-size: var(--fs-sm);
      color: rgba(215,255,233,0.8);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(18,49,38,0.8);
      background: rgba(11,15,13,0.6);
    }
    .timer.danger{
      border-color: rgba(255,43,43,0.75);
      color: rgba(255,200,200,0.95);
      box-shadow: 0 0 18px rgba(255,43,43,0.18);
      animation: timerPulse 700ms infinite;
    }
    @keyframes timerPulse{
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-1px); }
    }

    .iconBtn{
      border: 1px solid rgba(18,49,38,0.8);
      background: rgba(11,15,13,0.6);
      color: rgba(215,255,233,0.85);
      border-radius: 999px;
      padding: 8px 10px;
      font-size: var(--fs-sm);
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
    }
    .iconBtn:active{
      transform: translateY(1px);
    }

    main{
      flex: 1;
      display:flex;
      justify-content:center;
      padding: var(--pad);
      position: relative;
      z-index: 30; /* ensure cards above apparitions */
    }

    .wrap{
      width: min(720px, 100%);
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    .card{
      background: linear-gradient(to bottom, rgba(11,15,13,0.92), rgba(11,15,13,0.78));
      border: 1px solid rgba(18,49,38,0.85);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow:
        0 0 0 1px rgba(0,0,0,0.2) inset,
        0 24px 60px rgba(0,0,0,0.55);
      position: relative;
      overflow:hidden;
    }

    .card::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(400px 220px at 10% 0%, rgba(0,255,136,0.07), transparent 60%),
                  radial-gradient(380px 240px at 100% 10%, rgba(255,43,43,0.05), transparent 60%);
      opacity: calc(0.65 + var(--corruption) * 0.35);
      pointer-events:none;
    }

    h1, h2{
      margin: 0 0 10px 0;
      font-size: var(--fs-lg);
      line-height: 1.15;
    }

    .sub{
      margin-top: -4px;
      color: rgba(135,191,168,0.95);
      font-size: var(--fs-sm);
      line-height: 1.3;
    }

    p{
      margin: 10px 0;
      line-height: 1.45;
      color: rgba(215,255,233,0.92);
    }

    .muted{
      color: rgba(135,191,168,0.9);
      font-size: var(--fs-sm);
    }

    .puzzle{
      margin: 12px 0;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px dashed rgba(0,255,136,0.35);
      background: rgba(0,0,0,0.28);
      color: rgba(215,255,233,0.9);
      white-space: pre-wrap;
      word-break: break-word;
      font-size: clamp(14px, 3.6vw, 16px);
      position: relative;
    }

    .inputRow{
      display:flex;
      gap: 10px;
      align-items:stretch;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    input{
      flex: 1 1 220px;
      min-width: 0;
      border-radius: 12px;
      border: 1px solid rgba(18,49,38,0.9);
      background: rgba(0,0,0,0.35);
      color: rgba(215,255,233,0.95);
      padding: 14px 14px;
      font-size: var(--fs);
      outline: none;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.2) inset;
    }
    input:focus{
      border-color: rgba(0,255,136,0.65);
      box-shadow: 0 0 0 3px rgba(0,255,136,0.12);
    }

    .btn{
      flex: 0 0 auto;
      border-radius: 12px;
      border: 1px solid rgba(0,255,136,0.55);
      background: rgba(0,255,136,0.12);
      color: rgba(215,255,233,0.95);
      padding: 14px 16px;
      font-size: var(--fs-sm);
      font-weight: 700;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }

    .btn.red{
      border-color: rgba(255,43,43,0.6);
      background: rgba(255,43,43,0.10);
    }

    .feedback{
      margin-top: 12px;
      min-height: 22px;
      font-size: var(--fs-sm);
      color: rgba(255,200,200,0.95);
    }

    .hint{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,204,102,0.45);
      background: rgba(255,204,102,0.08);
      color: rgba(255,235,200,0.92);
      font-size: var(--fs-sm);
      line-height: 1.35;
    }

    /* Glitch text effect */
    .glitch{
      position: relative;
      display:inline-block;
      text-shadow:
        0 0 12px rgba(0,255,136,0.18),
        0 0 26px rgba(255,43,43,0.08);
    }
    .glitch::before,
    .glitch::after{
      content: attr(data-text);
      position:absolute;
      left:0; top:0;
      width:100%;
      overflow:hidden;
      pointer-events:none;
      opacity: calc(0.15 + var(--corruption) * 0.5);
    }
    .glitch::before{
      transform: translateX(calc(-1px - var(--corruption) * 2px));
      text-shadow: -2px 0 rgba(255,43,43,0.55);
      clip-path: inset(0 0 60% 0);
      animation: glitchA 2.1s infinite linear;
    }
    .glitch::after{
      transform: translateX(calc(1px + var(--corruption) * 2px));
      text-shadow: 2px 0 rgba(0,255,136,0.45);
      clip-path: inset(55% 0 0 0);
      animation: glitchB 1.7s infinite linear;
    }

    @keyframes glitchA{
      0%, 100% { clip-path: inset(0 0 60% 0); transform: translateX(-1px); }
      10% { clip-path: inset(0 0 40% 0); transform: translateX(-2px); }
      25% { clip-path: inset(10% 0 50% 0); transform: translateX(-1px); }
      42% { clip-path: inset(0 0 62% 0); transform: translateX(-3px); }
      65% { clip-path: inset(18% 0 44% 0); transform: translateX(-2px); }
    }
    @keyframes glitchB{
      0%, 100% { clip-path: inset(55% 0 0 0); transform: translateX(1px); }
      18% { clip-path: inset(62% 0 0 0); transform: translateX(3px); }
      33% { clip-path: inset(52% 0 10% 0); transform: translateX(2px); }
      58% { clip-path: inset(70% 0 0 0); transform: translateX(4px); }
      77% { clip-path: inset(50% 0 18% 0); transform: translateX(2px); }
    }

    /* Intro line + cursor */
    .introLine{
      display:flex;
      align-items:flex-end;
      gap: 8px;
      min-height: 4.2em;
    }
    .introText{
      margin:0;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: clamp(18px, 4.4vw, 24px);
      line-height: 1.25;
      color: rgba(215,255,233,0.95);
    }
    .cursor{
      display:inline-block;
      width: 10px;
      color: rgba(0,255,136,0.95);
      text-shadow: 0 0 18px rgba(0,255,136,0.45);
      animation: cursorBlink 1.0s steps(2,end) infinite;
      transform: translateY(-2px);
    }
    @keyframes cursorBlink{
      0%, 40% { opacity: 1; }
      41%, 100% { opacity: 0.0; }
    }

    .fadeOut{
      animation: fadeOut 520ms ease forwards;
    }
    @keyframes fadeOut{
      to { opacity: 0; transform: translateY(2px); filter: blur(0.6px); }
    }

    .fadeIn{
      animation: fadeIn 360ms ease forwards;
    }
    @keyframes fadeIn{
      from { opacity: 0; transform: translateY(4px); filter: blur(0.6px); }
      to { opacity: 1; transform: translateY(0); filter: blur(0); }
    }

    /* Flash overlay */
    .flash{
      position: fixed;
      inset: 0;
      pointer-events:none;
      background: radial-gradient(900px 600px at 50% 40%, rgba(255,43,43,0.35), transparent 60%),
                  rgba(255,43,43,0.12);
      opacity: 0;
      z-index: 80;
    }
    .flash.on{
      animation: flash 260ms ease;
    }
    @keyframes flash{
      0% { opacity: 0; }
      30% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Shake effect */
    .shake{
      animation: shake 360ms ease;
    }
    @keyframes shake{
      0% { transform: translate3d(0,0,0); }
      15% { transform: translate3d(-2px, 1px,0); }
      30% { transform: translate3d(2px, -1px,0); }
      45% { transform: translate3d(-3px, 0,0); }
      60% { transform: translate3d(3px, 1px,0); }
      100% { transform: translate3d(0,0,0); }
    }

    /* Overlay start */
    .overlay{
      position: fixed;
      inset: 0;
      z-index: 90;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: var(--pad);
      background: radial-gradient(900px 700px at 50% 20%, rgba(0,255,136,0.10), transparent 60%),
                  radial-gradient(900px 700px at 60% 70%, rgba(255,43,43,0.08), transparent 60%),
                  rgba(5,5,5,0.92);
      backdrop-filter: blur(10px);
    }

    .overlay .card{
      width: min(680px, 100%);
    }

    .pillRow{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    .pill{
      font-size: var(--fs-sm);
      color: rgba(215,255,233,0.85);
      padding: 6px 10px;
      border: 1px solid rgba(18,49,38,0.75);
      border-radius: 999px;
      background: rgba(0,0,0,0.25);
    }

    /* Syslog bottom */
    footer{
      padding: 0 var(--pad) var(--pad);
      z-index: 35;
      position: relative;
    }
    #finalPhoto.revealPhoto{
      opacity: 0;
      transform: scale(1.03);
      filter: contrast(1.08) brightness(0.92) saturate(0.9);
      animation: revealPhoto 1600ms ease forwards;
      box-shadow: 0 0 28px rgba(255,43,43,0.14);
    }
    @keyframes revealPhoto{
      to { opacity: 1; transform: scale(1); }
    }

    .syslog{
      width: min(720px, 100%);
      margin: 0 auto;
      font-size: var(--fs-sm);
      color: rgba(135,191,168,0.92);
      opacity: calc(0.75 + var(--corruption) * 0.25);
      border-top: 1px dashed rgba(18,49,38,0.6);
      padding-top: 10px;
      min-height: 46px;
      line-height: 1.25;
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Utilities */
    .hidden{ display:none !important; }
    .row{ display:flex; align-items:center; gap: 10px; flex-wrap: wrap; }
    .spacer{ height: 6px; }

    @media (prefers-reduced-motion: reduce){
      .app::after, .app::before, .glitch::before, .glitch::after, .cursor,
      .apparition, .apparition .eyes { animation: none !important; }
      .timer.danger{ animation: none !important; }
    }


    
  </style>
</head>

<body>
  <!-- START OVERLAY (needed for mobile audio) -->
  <div id="startOverlay" class="overlay">
    <div class="card fadeIn">
      <h1 class="glitch" data-text="HE IS ALREADY HERE">HE IS ALREADY HERE</h1>
      <div class="sub">–°—Ç—Ä–∞—à–Ω—ã–π –Ω–æ–≤–æ–≥–æ–¥–Ω–∏–π –∫–≤–µ—Å—Ç. 5 —ç—Ç–∞–ø–æ–≤. –¢–µ–ª–µ—Ñ–æ–Ω –¥—Ä—É–∂–µ–ª—é–±–µ–Ω. –ù–µ—Ä–≤—ã ‚Äî –Ω–µ—Ç.</div>

      <div class="spacer"></div>

      <p class="muted">
        –í–∫–ª—é—á–∏ –∑–≤—É–∫ –∏ (–∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ) –Ω–∞—É—à–Ω–∏–∫–∏.<br>
        –ù–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ –∑–≤—É–∫ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ —Ç–∞–ø–∞ ‚Äî —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ.
      </p>

      <div class="pillRow">
        <div class="pill">ASCII</div>
        <div class="pill">–¶–µ–∑–∞—Ä—å</div>
        <div class="pill">–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞</div>
        <div class="pill">—Ç–∞–π–º–µ—Ä</div>
        <div class="pill">–≥–ª—é–∫–∏</div>
        <div class="pill">–ª–∏—Ü–∞</div>
        <div class="pill">–º—É–∑—ã–∫–∞</div>
      </div>

      <div class="spacer"></div>

      <div class="row">
        <button id="startBtn" class="btn">–ù–ê–ß–ê–¢–¨</button>
        <button id="muteBtnOverlay" class="btn red" type="button">–°–†–ê–ó–£ –ë–ï–ó –ó–í–£–ö–ê</button>
      </div>

      <p class="muted" style="margin-top:12px">
        <span style="color: rgba(255,200,200,0.95)">–í–∞–∂–Ω–æ:</span>
        –µ—Å—Ç—å –ª—ë–≥–∫–∏–µ –≤—Å–ø—ã—à–∫–∏/–≥–ª—é–∫–∏. –ï—Å–ª–∏ –∫–æ–º—É-—Ç–æ –Ω–µ–ª—å–∑—è ‚Äî –≤—ã–∫–ª—é—á–∏ —ç—Ñ—Ñ–µ–∫—Ç—ã –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –û–°.
      </p>

      <p class="muted" style="margin-top:10px; opacity:0.75">
        –°–æ–∑–¥–∞—Ç–µ–ª—é: <code>?skip=1</code> –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –∏–Ω—Ç—Ä–æ, <code>?reset=1</code> —Å–±—Ä–æ—Å –ø—Ä–æ–≥—Ä–µ—Å—Å–∞.
      </p>
    </div>
  </div>

  <!-- FLASH OVERLAY -->
  <div id="flash" class="flash"></div>

  <!-- APP -->
  <div id="app" class="app hidden">

    <!-- APPARITIONS -->
    <div class="apparitions" aria-hidden="true">
      <div id="faceLeft" class="apparition left">
        <!-- Left face (inline SVG) -->
        <svg viewBox="0 0 300 600" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <filter id="distL">
              <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="2" seed="2" result="n"/>
              <feDisplacementMap in="SourceGraphic" in2="n" scale="10" xChannelSelector="R" yChannelSelector="G"/>
              <feGaussianBlur stdDeviation="0.35"/>
            </filter>
            <radialGradient id="skinL" cx="50%" cy="35%" r="70%">
              <stop offset="0" stop-color="rgba(215,255,233,0.14)"/>
              <stop offset="0.55" stop-color="rgba(215,255,233,0.05)"/>
              <stop offset="1" stop-color="rgba(0,0,0,0)"/>
            </radialGradient>
          </defs>

          <ellipse cx="150" cy="310" rx="120" ry="240" fill="url(#skinL)"/>

          <g filter="url(#distL)">
            <g class="eyes">
              <ellipse cx="110" cy="220" rx="26" ry="18" fill="rgba(245,255,250,0.95)"/>
              <ellipse cx="190" cy="220" rx="26" ry="18" fill="rgba(245,255,250,0.95)"/>
              <circle cx="110" cy="220" r="6" fill="rgba(255,43,43,0.95)"/>
              <circle cx="190" cy="220" r="6" fill="rgba(255,43,43,0.95)"/>
            </g>

            <path d="M92 360 C122 412 178 412 208 360" fill="none"
                  stroke="rgba(255,43,43,0.35)" stroke-width="12" stroke-linecap="round"/>

            <path d="M78 190 C105 165 127 165 150 180 C173 165 195 165 222 190"
                  fill="none" stroke="rgba(0,255,136,0.18)" stroke-width="6" stroke-linecap="round"/>
          </g>
        </svg>
      </div>

      <div id="faceRight" class="apparition right">
        <!-- Right face (inline SVG, different seed) -->
        <svg viewBox="0 0 300 600" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <filter id="distR">
              <feTurbulence type="fractalNoise" baseFrequency="0.85" numOctaves="2" seed="7" result="n"/>
              <feDisplacementMap in="SourceGraphic" in2="n" scale="12" xChannelSelector="R" yChannelSelector="G"/>
              <feGaussianBlur stdDeviation="0.4"/>
            </filter>
            <radialGradient id="skinR" cx="50%" cy="34%" r="72%">
              <stop offset="0" stop-color="rgba(255,200,200,0.11)"/>
              <stop offset="0.55" stop-color="rgba(215,255,233,0.05)"/>
              <stop offset="1" stop-color="rgba(0,0,0,0)"/>
            </radialGradient>
          </defs>

          <ellipse cx="150" cy="312" rx="118" ry="238" fill="url(#skinR)"/>

          <g filter="url(#distR)">
            <g class="eyes">
              <ellipse cx="110" cy="218" rx="25" ry="18" fill="rgba(245,255,250,0.92)"/>
              <ellipse cx="190" cy="218" rx="25" ry="18" fill="rgba(245,255,250,0.92)"/>
              <circle cx="110" cy="218" r="7" fill="rgba(255,43,43,0.95)"/>
              <circle cx="190" cy="218" r="7" fill="rgba(255,43,43,0.95)"/>
            </g>

            <path d="M86 362 C116 330 184 330 214 362" fill="none"
                  stroke="rgba(255,43,43,0.28)" stroke-width="12" stroke-linecap="round"/>

            <path d="M85 188 C120 150 180 150 215 188"
                  fill="none" stroke="rgba(0,255,136,0.16)" stroke-width="6" stroke-linecap="round"/>
          </g>
        </svg>
      </div>
    </div>

    <header>
      <div class="brand">
        <span class="pip"></span>
        <span>NY-QUEST</span>
      </div>

      <div class="status">
        <div id="progress" class="progress" aria-label="progress"></div>
        <div id="timer" class="timer">--:--</div>
        <button id="muteBtn" class="iconBtn" type="button" aria-label="mute">üîä</button>
      </div>
    </header>

    <main>
      <div class="wrap">

        <!-- INTRO SCREEN -->
        <section id="introCard" class="card">
          <div class="introLine">
            <pre id="introText" class="introText"></pre>
            <span id="cursor" class="cursor">‚ñÆ</span>
          </div>
          <div class="muted" style="margin-top:10px">
            –ù–µ –∑–∞–∫—Ä—ã–≤–∞–π —Å—Ç—Ä–∞–Ω–∏—Ü—É. –ù–µ –æ–±–Ω–æ–≤–ª—è–π. –û–Ω –Ω–µ –ª—é–±–∏—Ç, –∫–æ–≥–¥–∞ –µ–º—É –º–µ—à–∞—é—Ç.
          </div>
        </section>

        <!-- STAGE SCREEN -->
        <section id="stageCard" class="card hidden"></section>

        <!-- FINAL SCREEN -->
        <section id="finalCard" class="card hidden">
          <h2 class="glitch" data-text="–§–ò–ù–ê–õ">–§–ò–ù–ê–õ</h2>
          <p>
            –¢—ã –¥–æ—à—ë–ª –¥–æ –∫–æ–Ω—Ü–∞.<br>
            –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –Ω–µ –¥–æ—Ö–æ–¥—è—Ç.
          </p>
          <p class="muted">
            –ù–∏–∂–µ ‚Äî —Ç–æ, —á—Ç–æ —Ç—ã –∑–∞—Å–ª—É–∂–∏–ª.
          </p>

          <div class="puzzle" style="border-style: solid; border-color: rgba(0,255,136,0.25)">
            <strong style="color: rgba(0,255,136,0.9)">–° –ù–æ–≤—ã–º –≥–æ–¥–æ–º.</strong><br>
            –û–Ω –±–æ–ª—å—à–µ –Ω–µ –ø—Ä—è—á–µ—Ç—Å—è, –Ω–æ —Ç—ã –¥–æ–ª–∂–µ–Ω –Ω–∞–π—Ç–∏ –µ–≥–æ...
          </div>

          <div id="finalPhotoWrap" class="puzzle" style="padding: 10px; border-style: dashed;">
            <div class="muted" style="margin-bottom:8px">–û–Ω —Å–ø—Ä—è—Ç–∞–ª —Ç–≤–æ–π –ø–æ–¥–∞—Ä–æ–∫!</div>
            <img id="finalPhoto" alt="final" style="width:100%; border-radius:12px; display:none;" />
            <div id="finalNoPhoto" class="muted">
              (–ü–æ–∫–∞ –Ω–µ –≤—Å—Ç–∞–≤–ª–µ–Ω–æ. –¢—ã –¥–æ–±–∞–≤–∏—à—å —Å—Å—ã–ª–∫—É/—Ñ–∞–π–ª –ø–æ–∑–∂–µ ‚Äî —Å–º. –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –≤ –∫–æ–¥–µ.)
            </div>
          </div>

          <button id="restartBtn" class="btn red" type="button" style="margin-top:10px">–°–ë–†–û–°–ò–¢–¨ –ò –ü–†–û–ô–¢–ò –°–ù–û–í–ê</button>
        </section>

      </div>
    </main>

    <footer>
      <div id="syslog" class="syslog"></div>
    </footer>
  </div>

  <script>
    /******************************************************************
     * –ù–ê–°–¢–†–û–ô–ö–ò (—Å–æ–∑–¥–∞—Ç–µ–ª—å)
     ******************************************************************/
    const CONFIG = {
      // –§–∏–Ω–∞–ª—å–Ω–æ–µ —Ñ–æ—Ç–æ: URL –∏–ª–∏ –ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª —Ä—è–¥–æ–º (–Ω–∞–ø—Ä–∏–º–µ—Ä "final.jpg")
      FINAL_PHOTO_URL: "./photo_2025-12-31_18-53-41.jpg",

      // –†–µ–∞–ª—å–Ω–∞—è –º—É–∑—ã–∫–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ):
      // –ø–æ–ª–æ–∂–∏ music.mp3 —Ä—è–¥–æ–º —Å index.html –∏ –ø–æ—Å—Ç–∞–≤—å "music.mp3"
      // –µ—Å–ª–∏ –ø—É—Å—Ç–æ ‚Äî –±—É–¥–µ—Ç —Å–∏–Ω—Ç–µ–∑-—Å–∞—É–Ω–¥—Ç—Ä–µ–∫
      MUSIC_URL: "",

      AUTO_START_STAGE_1_AFTER_INTRO: true,
      INTRO_CAN_BE_SKIPPED_WITH_QUERY: true,  // ?skip=1
      SAVE_PROGRESS: true,
      HARD_RESET_ON_REFRESH: false,

      STAGE_TIME: { 1: 90, 2: 110, 3: 95, 4: 85, 5: 80 },

      WRONG_ANSWER_PENALTY_SEC: 12,
      TIMEOUT_PENALTY_BACK_STAGES: 1,

      CORRUPTION_PER_WRONG: 1,
      CORRUPTION_PER_TIMEOUT: 2,

      HINT_AFTER_ATTEMPTS: 2,
      STRONG_HINT_AFTER_ATTEMPTS: 4,

      RANDOM_GLITCH_EVERY_MS: 5200,
      RANDOM_GLITCH_CHANCE: 0.38,
      JUMPSCARE_CHANCE: 0.14,

      FACE_PEEK_CHANCE: 0.45,
      FACE_PEEK_STRONG_CHANCE: 0.14
    };

    /******************************************************************
     * –î–ê–ù–ù–´–ï –ö–í–ï–°–¢–ê
     ******************************************************************/
    const STAGES = [
      {
        id: 1,
        title: "–≠–¢–ê–ü 1 / –ß–∏—Å–ª–∞ –Ω–µ –º–æ–ª—á–∞—Ç",
        subtitle: "–ü—Ä–æ—á–∏—Ç–∞–π —Ç–æ, —á—Ç–æ —Å–∫—Ä—ã—Ç–æ –≤ —á–∏—Å–ª–∞—Ö.",
        story: [
          "–¢—ã –∑–¥–µ—Å—å –Ω–µ —Å–ª—É—á–∞–π–Ω–æ.",
          "–ö–∞–∂–¥–æ–µ —á–∏—Å–ª–æ ‚Äî —Å–∏–º–≤–æ–ª. –ú–∞—à–∏–Ω—ã –≥–æ–≤–æ—Ä–∏–ª–∏ —Ç–∞–∫ —Å —Å–∞–º–æ–≥–æ –Ω–∞—á–∞–ª–∞.",
          "–í–≤–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é."
        ],
        puzzle: "72 101 108 108 111 44 32 66 114 111 116 104 101 114",
        placeholder: "—Ä–∞—Å—à–∏—Ñ—Ä—É–π –∏ –≤–≤–µ–¥–∏ —Ç–µ–∫—Å—Ç‚Ä¶",
        inputmode: "text",
        check: (raw) => normalizeText(raw) === "hello, brother",
        hints: [
          "–ü–æ–¥—Å–∫–∞–∑–∫–∞: —ç—Ç–æ ASCII-–∫–æ–¥—ã. –ü–µ—Ä–µ–≤–µ–¥–∏ —á–∏—Å–ª–∞ –≤ —Å–∏–º–≤–æ–ª—ã (—Ç–∞–±–ª–∏—Ü–∞ ASCII / –æ–Ω–ª–∞–π–Ω-–¥–µ–∫–æ–¥–µ—Ä).",
          "–°–∏–ª—å–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞: –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å ‚ÄúHello,‚Äù –∏ –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –∫ –±—Ä–∞—Ç—É."
        ]
      },
      {
        id: 2,
        title: "–≠–¢–ê–ü 2 / –°–¥–≤–∏–≥",
        subtitle: "–°–ª–æ–≤–∞ –æ—Å—Ç–∞–ª–∏—Å—å —Ç–µ–º–∏ –∂–µ. –û–Ω–∏ –ø—Ä–æ—Å—Ç–æ‚Ä¶ —Å–º–µ—Å—Ç–∏–ª–∏—Å—å.",
        story: [
          "–í –¥—Ä–µ–≤–Ω–æ—Å—Ç–∏ –≤–µ—Ä–∏–ª–∏: –µ—Å–ª–∏ —Å–¥–≤–∏–Ω—É—Ç—å –±—É–∫–≤—ã, —Å–º—ã—Å–ª –≤—Å—ë –µ—â—ë –º–æ–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å.",
          "–ü–æ–¥—Å–∫–∞–∑–∫–∞ —Å–ø—Ä—è—Ç–∞–Ω–∞ –≤ –ø–µ—Ä–≤–æ–º —ç—Ç–∞–ø–µ: —Å—Ä–∞–≤–Ω–∏ –ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ –∏–∑ —ç—Ç–∞–ø–∞ 1 –∏ –ø–µ—Ä–≤–æ–µ —Å–ª–æ–≤–æ –∑–¥–µ—Å—å.",
          "–†–∞—Å—à–∏—Ñ—Ä—É–π —Å—Ç—Ä–æ–∫—É –∏ –≤–≤–µ–¥–∏ –æ—Ç–≤–µ—Ç."
        ],
        puzzle: "Khoor, Qhz Zhdu",
        placeholder: "–¥–µ–∫–æ–¥–∏—Ä—É–π –∏ –≤–≤–µ–¥–∏ —Ñ—Ä–∞–∑—É‚Ä¶",
        inputmode: "text",
        check: (raw) => normalizeText(raw) === "hello, new year",
        hints: [
          "–ü–æ–¥—Å–∫–∞–∑–∫–∞: —ç—Ç–æ —à–∏—Ñ—Ä –¶–µ–∑–∞—Ä—è (—Å–¥–≤–∏–≥ –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É).",
          "–°–∏–ª—å–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞: —Å–¥–≤–∏–≥ = 3. (K‚ÜíH, h‚Üíe ‚Ä¶)"
        ]
      },
      {
        id: 3,
        title: "–≠–¢–ê–ü 3 / –ß–∏—Å–ª–∞ –ª–≥—É—Ç",
        subtitle: "–û—à–∏–±–∫–∞ –Ω–∞ –æ–¥–Ω–æ–º —à–∞–≥–µ –º–µ–Ω—è–µ—Ç –≤—Å—ë.",
        story: [
          "–ü–æ—Ä—è–¥–æ–∫ –≤–∞–∂–µ–Ω. –°–Ω–∞—á–∞–ª–∞ —Å—Ç–µ–ø–µ–Ω–∏, –ø–æ—Ç–æ–º —Å–∫–æ–±–∫–∏, –ø–æ—Ç–æ–º —É–º–Ω–æ–∂–µ–Ω–∏–µ.",
          "–ù–µ —Ç–æ—Ä–æ–ø–∏—Å—å. –û–Ω –∂–¥—ë—Ç, –∫–æ–≥–¥–∞ —Ç—ã –æ—à–∏–±—ë—à—å—Å—è."
        ],
        puzzle: "(2¬≤ + 3¬≥) √ó 2 ‚àí 4",
        placeholder: "–≤–≤–µ–¥–∏ —á–∏—Å–ª–æ‚Ä¶",
        inputmode: "numeric",
        check: (raw) => {
          const n = parseInt(String(raw).trim(), 10);
          return Number.isFinite(n) && n === 58;
        },
        hints: [
          "–ü–æ–¥—Å–∫–∞–∑–∫–∞: 2¬≤=4, 3¬≥=27. –ü–æ—Ç–æ–º (4+27)√ó2‚àí4.",
          "–°–∏–ª—å–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞: –æ—Ç–≤–µ—Ç = 58."
        ]
      },
      {
        id: 4,
        title: "–≠–¢–ê–ü 4 / –ú–∞—à–∏–Ω–Ω—ã–π —è–∑—ã–∫",
        subtitle: "–¢—ã —É–∂–µ –≤–∏–¥–µ–ª —Ç–∞–∫–∏–µ —á–∏—Å–ª–∞. –ù–µ –ø—Ä–∏—Ç–≤–æ—Ä—è–π—Å—è, —á—Ç–æ –∑–∞–±—ã–ª.",
        story: [
          "–ß–∏—Å–ª–∞ ‚Üí —Å–∏–º–≤–æ–ª—ã ‚Üí —Å–ª–æ–≤–æ.",
          "–ò –¥–∞‚Ä¶ –æ–Ω–æ —Å–≤—è–∑–∞–Ω–æ —Å —ç—Ç–∏–º –≤—Ä–µ–º–µ–Ω–µ–º –≥–æ–¥–∞."
        ],
        puzzle: "83 65 78 84 65",
        placeholder: "–≤–≤–µ–¥–∏ —Å–ª–æ–≤–æ‚Ä¶",
        inputmode: "text",
        check: (raw) => normalizeText(raw) === "santa",
        hints: [
          "–ü–æ–¥—Å–∫–∞–∑–∫–∞: —Å–Ω–æ–≤–∞ ASCII. –ü–µ—Ä–µ–≤–µ–¥–∏ –≤ –±—É–∫–≤—ã.",
          "–°–∏–ª—å–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞: SANTA."
        ]
      },
      {
        id: 5,
        title: "–≠–¢–ê–ü 5 / –ü–æ—Å–ª–µ–¥–Ω–∏–π –∫–ª—é—á",
        subtitle: "–û–Ω –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –∫–ª—é—á.",
        story: [
          "–°–æ–±–µ—Ä–∏ –∫–ª—é—á –∏–∑ –ø—Ä–æ—à–ª—ã—Ö —ç—Ç–∞–ø–æ–≤.",
          "–í–æ–∑—å–º–∏ –°–î–í–ò–ì (—ç—Ç–∞–ø 2) –∏ –†–ï–ó–£–õ–¨–¢–ê–¢ (—ç—Ç–∞–ø 3).",
          "–°–∫–ª–µ–π –∏—Ö –ë–ï–ó –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –≤–≤–µ–¥–∏."
        ],
        puzzle: "–∫–ª—é—á = [—Å–¥–≤–∏–≥] + [–æ—Ç–≤–µ—Ç]",
        placeholder: "–Ω–∞–ø—Ä–∏–º–µ—Ä: 358",
        inputmode: "numeric",
        check: (raw) => {
          const s = String(raw).trim().replace(/\s+/g, "");
          return s === "358";
        },
        hints: [
          "–ü–æ–¥—Å–∫–∞–∑–∫–∞: —Å–¥–≤–∏–≥ –¶–µ–∑–∞—Ä—è = 3.",
          "–°–∏–ª—å–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞: –∫–ª—é—á = 358."
        ]
      }
    ];

    /******************************************************************
     * –£–¢–ò–õ–ò–¢–´
     ******************************************************************/
    const $ = (sel) => document.querySelector(sel);
    function normalizeText(s){
      return String(s ?? "").trim().replace(/\s+/g, " ").toLowerCase();
    }
    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function mmss(seconds){
      const s = Math.max(0, Math.floor(seconds));
      const m = Math.floor(s / 60);
      const r = s % 60;
      return String(m).padStart(2,"0") + ":" + String(r).padStart(2,"0");
    }
    function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    /******************************************************************
     * –•–†–ê–ù–ò–õ–ò–©–ï
     ******************************************************************/
    const STORAGE_KEY = "ny_quest_progress_v2";
    function loadProgress(){
      if (!CONFIG.SAVE_PROGRESS) return null;
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      }catch{ return null; }
    }
    function saveProgress(data){
      if (!CONFIG.SAVE_PROGRESS) return;
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }catch{}
    }
    function clearProgress(){ try{ localStorage.removeItem(STORAGE_KEY); }catch{} }

    /******************************************************************
     * –ê–£–î–ò–û (WebAudio + optional mp3 via MediaElementSource)
     ******************************************************************/
    const AudioEngine = (() => {
      let ctx = null;
      let master = null;
      let muted = false;

      // ambience
      let bgNoise = null;
      let bgOsc = null;
      let lfo = null;

      // synth music
      let musicTimer = null;
      let musicStep = 0;
      let musicGain = null;
      let musicDelay = null;
      let musicFb = null;
      let musicLP = null;

      // optional audio file
      let musicEl = null;
      let musicNode = null;

      function ensure(){
        if (ctx) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        ctx = new AC();
        master = ctx.createGain();
        master.gain.value = 0.85;
        master.connect(ctx.destination);
      }

      function setMuted(m){
        muted = !!m;
        if (!master) return;
        master.gain.setTargetAtTime(muted ? 0.0 : 0.85, ctx.currentTime, 0.015);
      }

      async function resume(){
        ensure();
        if (ctx.state !== "running"){
          await ctx.resume();
        }
      }

      function startBackground(){
        ensure();
        if (bgNoise || bgOsc) return;

        // Noise buffer
        const bufferSize = ctx.sampleRate * 2;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++){
          data[i] = (Math.random()*2 - 1) * 0.35;
        }
        const noise = ctx.createBufferSource();
        noise.buffer = buffer;
        noise.loop = true;

        const band = ctx.createBiquadFilter();
        band.type = "bandpass";
        band.frequency.value = 220;
        band.Q.value = 0.7;

        const hiss = ctx.createBiquadFilter();
        hiss.type = "highpass";
        hiss.frequency.value = 90;

        const g = ctx.createGain();
        g.gain.value = 0.08;

        noise.connect(band);
        band.connect(hiss);
        hiss.connect(g);
        g.connect(master);

        // Low drone oscillator
        const osc = ctx.createOscillator();
        osc.type = "sine";
        osc.frequency.value = 54;

        const oscGain = ctx.createGain();
        oscGain.gain.value = 0.07;

        const oscFilter = ctx.createBiquadFilter();
        oscFilter.type = "lowpass";
        oscFilter.frequency.value = 160;

        osc.connect(oscFilter);
        oscFilter.connect(oscGain);
        oscGain.connect(master);

        // LFO for subtle wobble
        const l = ctx.createOscillator();
        l.type = "sine";
        l.frequency.value = 0.15;

        const lGain = ctx.createGain();
        lGain.gain.value = 18;

        l.connect(lGain);
        lGain.connect(band.frequency);

        noise.start();
        osc.start();
        l.start();

        bgNoise = noise;
        bgOsc = osc;
        lfo = l;
      }

      function stopBackground(){
        try{ bgNoise && bgNoise.stop(); }catch{}
        try{ bgOsc && bgOsc.stop(); }catch{}
        try{ lfo && lfo.stop(); }catch{}
        bgNoise = bgOsc = lfo = null;
      }

      function blip(freq=880, dur=0.03, type="square", gain=0.12){
        ensure();
        const t0 = ctx.currentTime;
        const o = ctx.createOscillator();
        o.type = type;
        o.frequency.setValueAtTime(freq, t0);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(gain, t0 + 0.005);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        o.connect(g);
        g.connect(master);
        o.start(t0);
        o.stop(t0 + dur + 0.01);
      }

      function noiseBurst(dur=0.12, gain=0.18){
        ensure();
        const t0 = ctx.currentTime;
        const bufferSize = Math.floor(ctx.sampleRate * dur);
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++){
          data[i] = (Math.random()*2 - 1) * 0.9;
        }
        const src = ctx.createBufferSource();
        src.buffer = buffer;

        const hp = ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 700;

        const g = ctx.createGain();
        g.gain.value = gain;

        src.connect(hp);
        hp.connect(g);
        g.connect(master);

        src.start(t0);
        src.stop(t0 + dur + 0.01);
      }

      function typeClick(){
        blip(1100 + Math.random()*200, 0.02, "square", 0.07);
      }

      function success(){
        blip(784, 0.06, "triangle", 0.12);
        setTimeout(() => blip(988, 0.07, "triangle", 0.11), 70);
        setTimeout(() => blip(1175, 0.08, "triangle", 0.10), 140);
      }

      function fail(){
        // harsher + dissonant
        noiseBurst(0.18, 0.22);
        blip(150, 0.14, "sawtooth", 0.11);
        setTimeout(() => blip(138, 0.11, "sawtooth", 0.10), 40);
      }

      function glitch(){
        blip(220 + Math.random()*80, 0.04, "square", 0.09);
        noiseBurst(0.06, 0.10);
      }

      // ======== SCARY MUSIC LAYER ========
      function midiToFreq(m){
        return 440 * Math.pow(2, (m - 69) / 12);
      }

      function playNote(midi, dur=0.28, gain=0.07, type="triangle", detuneCents=0){
        ensure();
        const t0 = ctx.currentTime;

        const o = ctx.createOscillator();
        o.type = type;
        o.frequency.setValueAtTime(midiToFreq(midi), t0);
        o.detune.setValueAtTime(detuneCents, t0);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(gain, t0 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        // route
        o.connect(g);
        g.connect(musicLP);

        o.start(t0);
        o.stop(t0 + dur + 0.02);
      }

      function playBell(midi){
        // a thin "ice bell"
        ensure();
        const t0 = ctx.currentTime;

        const o = ctx.createOscillator();
        o.type = "sine";
        o.frequency.setValueAtTime(midiToFreq(midi), t0);

        const hp = ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 900;

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(0.06, t0 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.7);

        o.connect(hp);
        hp.connect(g);
        g.connect(musicLP);

        o.start(t0);
        o.stop(t0 + 0.75);
      }

      function setupMusicBus(){
        if (musicLP) return;

        musicGain = ctx.createGain();
        musicGain.gain.value = 0.95; // overall music chain (final loudness controlled in notes)

        musicLP = ctx.createBiquadFilter();
        musicLP.type = "lowpass";
        musicLP.frequency.value = 1100;

        musicDelay = ctx.createDelay();
        musicDelay.delayTime.value = 0.30;

        musicFb = ctx.createGain();
        musicFb.gain.value = 0.32;

        // feedback loop
        musicDelay.connect(musicFb);
        musicFb.connect(musicDelay);

        // chain: notes -> LP -> (dry+delay) -> master
        musicLP.connect(musicGain);
        musicGain.connect(master);

        // parallel delay for space
        musicLP.connect(musicDelay);
        musicDelay.connect(master);
      }

      async function startMusic(){
        await resume();
        ensure();
        setupMusicBus();

        // Prefer real track if provided
        if (musicEl || musicNode){
          // already started
        } else if (CONFIG.MUSIC_URL && CONFIG.MUSIC_URL.trim()){
          try{
            musicEl = new Audio();
            musicEl.src = CONFIG.MUSIC_URL.trim();
            musicEl.loop = true;
            musicEl.preload = "auto";

            // route through AudioContext to obey mute
            musicNode = ctx.createMediaElementSource(musicEl);
            const g = ctx.createGain();
            g.gain.value = 0.35; // mp3 level
            musicNode.connect(g);
            g.connect(master);

            await musicEl.play();
            return;
          }catch{
            // if fails, fall back to synth
          }
        }

        // Synth fallback
        if (musicTimer) return;

        // slow eerie progression in A minor-ish
        // chords as MIDI notes (A3=57, C4=60, E4=64 etc)
        const chords = [
          [57, 60, 64], // Am
          [53, 57, 60], // F
          [55, 59, 62], // G
          [52, 55, 59], // Em
        ];

        const beatMs = 620; // slow
        musicStep = 0;

        musicTimer = setInterval(() => {
          const chordIndex = Math.floor(musicStep / 8) % chords.length;
          const chord = chords[chordIndex];

          const note = chord[musicStep % chord.length];
          const det = (Math.random() * 10 - 5); // small detune
          playNote(note, 0.30, 0.065, "triangle", det);

          // occasional low octave
          if (Math.random() < 0.18){
            playNote(note - 12, 0.36, 0.038, "sine", det * 0.6);
          }

          // rare dissonance for creep
          if (Math.random() < 0.08){
            playNote(note + 1, 0.22, 0.024, "sine", det);
          }

          // ice bell sometimes
          if (Math.random() < 0.10){
            playBell(chord[0] + 24);
          }

          musicStep++;
        }, beatMs);
      }

      function stopMusic(){
        if (musicTimer){
          clearInterval(musicTimer);
          musicTimer = null;
        }
        if (musicEl){
          try{ musicEl.pause(); }catch{}
          musicEl = null;
        }
        musicNode = null;
      }

      return {
        resume,
        startBackground,
        stopBackground,
        startMusic,
        stopMusic,
        setMuted,
        typeClick,
        success,
        fail,
        glitch,
        get muted(){ return muted; }
      };
    })();

    /******************************************************************
     * UI + –õ–û–ì–ò–ö–ê
     ******************************************************************/
    const el = {
      startOverlay: $("#startOverlay"),
      startBtn: $("#startBtn"),
      muteBtnOverlay: $("#muteBtnOverlay"),

      app: $("#app"),
      muteBtn: $("#muteBtn"),
      timer: $("#timer"),
      progress: $("#progress"),
      syslog: $("#syslog"),
      flash: $("#flash"),

      introCard: $("#introCard"),
      introText: $("#introText"),
      cursor: $("#cursor"),

      stageCard: $("#stageCard"),
      finalCard: $("#finalCard"),
      finalPhoto: $("#finalPhoto"),
      finalNoPhoto: $("#finalNoPhoto"),
      restartBtn: $("#restartBtn"),

      faceLeft: $("#faceLeft"),
      faceRight: $("#faceRight"),
    };

    const urlParams = new URLSearchParams(location.search);
    const shouldSkipIntro = CONFIG.INTRO_CAN_BE_SKIPPED_WITH_QUERY && urlParams.get("skip") === "1";
    const shouldReset = urlParams.get("reset") === "1";

    const state = {
      stageId: 0,
      attempts: {},
      corruption: 0, // 0..12 internal
      timeLeft: 0,
      timerHandle: null,
      started: false,
      muted: false,
      lastTypeSoundAt: 0,
      randomFXHandle: null,
    };

    function setCorruption(add){
      state.corruption = clamp(state.corruption + add, 0, 12);
      const normalized = clamp(state.corruption / 12, 0, 1);
      document.documentElement.style.setProperty("--corruption", String(normalized));
      if (add > 0) syslog("CORRUPTION +" + add + " ‚ñí‚ñí‚ñí");
      saveGame();
    }

    function syslog(line){
      const now = new Date();
      const hh = String(now.getHours()).padStart(2,"0");
      const mm = String(now.getMinutes()).padStart(2,"0");
      const prefix = "[" + hh + ":" + mm + "] ";

      const existing = el.syslog.textContent.trim().split("\n").filter(Boolean);
      existing.push(prefix + line);
      while (existing.length > 6) existing.shift();
      el.syslog.textContent = existing.join("\n");
    }

    function flash(){
      el.flash.classList.remove("on");
      void el.flash.offsetWidth;
      el.flash.classList.add("on");
    }

    function shake(node){
      node.classList.remove("shake");
      void node.offsetWidth;
      node.classList.add("shake");
    }

    function vibrate(ms){
      try{ if (navigator.vibrate) navigator.vibrate(ms); }catch{}
    }

    function peekFaces(strong=false){
      const cls = strong ? "peekStrong" : "peek";
      for (const face of [el.faceLeft, el.faceRight]){
        if (!face) continue;
        face.classList.remove("peek","peekStrong");
        void face.offsetWidth;
        face.classList.add(cls);
      }
      setTimeout(() => {
        for (const face of [el.faceLeft, el.faceRight]){
          if (!face) continue;
          face.classList.remove("peek","peekStrong");
        }
      }, strong ? 520 : 340);
    }

    function renderProgress(activeId){
      el.progress.innerHTML = "";
      for (let i=1; i<=5; i++){
        const seg = document.createElement("div");
        seg.className = "seg" + (i <= activeId ? " on" : "");
        el.progress.appendChild(seg);
      }
    }

    function setTimer(seconds){
      clearTimer();
      state.timeLeft = seconds;
      updateTimerUI();

      state.timerHandle = setInterval(() => {
        state.timeLeft -= 1;
        updateTimerUI();
        if (state.timeLeft <= 0) onTimeout();
      }, 1000);
    }

    function clearTimer(){
      if (state.timerHandle){
        clearInterval(state.timerHandle);
        state.timerHandle = null;
      }
      el.timer.classList.remove("danger");
      el.timer.textContent = "--:--";
    }

    function updateTimerUI(){
      el.timer.textContent = mmss(state.timeLeft);
      if (state.timeLeft <= 15) el.timer.classList.add("danger");
      else el.timer.classList.remove("danger");
    }

    function penalizeTime(sec){
      state.timeLeft = Math.max(0, state.timeLeft - sec);
      updateTimerUI();
      syslog("TIME -" + sec + "s");
    }

    function saveGame(){
      if (!CONFIG.SAVE_PROGRESS) return;
      saveProgress({
        stageId: state.stageId,
        attempts: state.attempts,
        corruption: state.corruption,
        muted: state.muted
      });
    }

    function restoreGame(){
      if (shouldReset){
        clearProgress();
        return null;
      }
      const p = loadProgress();
      if (!p) return null;

      state.stageId = p.stageId ?? 0;
      state.attempts = p.attempts ?? {};
      state.corruption = p.corruption ?? 0;
      state.muted = !!p.muted;

      const normalized = clamp(state.corruption / 12, 0, 1);
      document.documentElement.style.setProperty("--corruption", String(normalized));
      return p;
    }

    function setMuted(m){
      state.muted = !!m;
      AudioEngine.setMuted(state.muted);
      el.muteBtn.textContent = state.muted ? "üîá" : "üîä";
      saveGame();
      syslog(state.muted ? "AUDIO MUTED" : "AUDIO LIVE");
    }

    function bindMuteButtons(){
      el.muteBtn.addEventListener("click", () => setMuted(!state.muted));
      el.muteBtnOverlay.addEventListener("click", async () => {
        setMuted(true);
        await startExperience();
      });
    }

    /******************************************************************
     * INTRO
     ******************************************************************/
    const INTRO_LINES = [
      "–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶",
      "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –¥–∞—Ç—ã: 31.12",
      "–ù–æ–≤–æ–≥–æ–¥–Ω–∏–π –ø—Ä–æ—Ç–æ–∫–æ–ª –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.",
      "–¢—ã –∑–¥–µ—Å—å –Ω–µ —Å–ª—É—á–∞–π–Ω–æ.",
      "–ò —Ç—ã –Ω–µ –ø–µ—Ä–≤—ã–π.",
      "–ï—Å–ª–∏ —Ç—ã —á–∏—Ç–∞–µ—à—å —ç—Ç–æ ‚Äî –≤—Ä–µ–º—è —É–∂–µ –Ω–∞—á–∞–ª–æ –∏—Å–∫–∞–∂–∞—Ç—å—Å—è.",
      "–ß—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å, –ø—Ä–æ—á–∏—Ç–∞–π —Ç–æ, —á—Ç–æ —Å–∫—Ä—ã—Ç–æ –≤ —á–∏—Å–ª–∞—Ö."
    ];

    async function runIntro(){
      el.introText.textContent = "";
      el.introCard.classList.remove("fadeOut");
      el.introCard.classList.add("fadeIn");

      const typeSpeed = 22;
      const holdMs = 850;
      const fadeMs = 520;

      for (let i=0; i<INTRO_LINES.length; i++){
        const line = INTRO_LINES[i];
        const isLast = i === INTRO_LINES.length - 1;

        el.introText.textContent = "";
        el.introCard.classList.remove("fadeOut");
        el.introCard.classList.add("fadeIn");

        for (let c=0; c<line.length; c++){
          el.introText.textContent += line[c];
          const now = performance.now();
          if (!state.muted && now - state.lastTypeSoundAt > 30){
            AudioEngine.typeClick();
            state.lastTypeSoundAt = now;
          }
          await sleep(typeSpeed + (Math.random()*18));
        }

        if (!state.muted) AudioEngine.glitch();

        // faces sometimes peek on intro lines
        if (Math.random() < 0.35) peekFaces(false);

        await sleep(isLast ? 900 : holdMs);

        if (!isLast){
          el.introCard.classList.remove("fadeIn");
          el.introCard.classList.add("fadeOut");
          await sleep(fadeMs);
        }
      }

      if (CONFIG.AUTO_START_STAGE_1_AFTER_INTRO){
        await sleep(450);
        goToStage(1);
      }
    }

    /******************************************************************
     * STAGE RENDER + CHECK
     ******************************************************************/
    function renderStage(stageId){
      const stage = STAGES.find(s => s.id === stageId);
      if (!stage) return;

      renderProgress(stageId);
      el.stageCard.classList.remove("hidden");
      el.finalCard.classList.add("hidden");
      el.introCard.classList.add("hidden");

      const attempts = state.attempts[stageId] ?? 0;

      el.stageCard.innerHTML = `
        <h2 class="glitch" data-text="${escapeHtml(stage.title)}">${escapeHtml(stage.title)}</h2>
        <div class="sub">${escapeHtml(stage.subtitle)}</div>

        ${stage.story.map(t => `<p>${escapeHtml(t)}</p>`).join("")}

        <div class="puzzle">${escapeHtml(stage.puzzle)}</div>

        <div class="inputRow">
          <input
            id="answerInput"
            type="text"
            inputmode="${stage.inputmode}"
            autocapitalize="off"
            autocorrect="off"
            spellcheck="false"
            placeholder="${escapeHtml(stage.placeholder)}"
            aria-label="answer"
          />
          <button id="submitBtn" class="btn" type="button">–ü–†–û–í–ï–†–ò–¢–¨</button>
          <button id="panicBtn" class="btn red" type="button" title="–Ω–∞–∂–º–∏, –µ—Å–ª–∏ –≤—Å—ë –ø—Ä–æ–ø–∞–ª–æ">–ü–ê–ù–ò–ö–ê</button>
        </div>

        <div id="feedback" class="feedback"></div>
        <div id="hintBox" class="hint ${shouldShowHint(stageId, attempts) ? "" : "hidden"}">
          ${escapeHtml(pickHint(stageId, attempts))}
        </div>

        <p class="muted" style="margin-top:12px">
          –ü–æ–¥—Å–∫–∞–∑–∫–∞: –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ –≤—ã–∫–ª—é—á–∏ –∞–≤—Ç–æ–∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—é, –µ—Å–ª–∏ –æ–Ω–∞ –º–µ—à–∞–µ—Ç.
        </p>
      `;

      const input = $("#answerInput");
      const submitBtn = $("#submitBtn");
      const panicBtn = $("#panicBtn");
      const feedback = $("#feedback");
      const hintBox = $("#hintBox");

      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter"){
          onSubmit();
        }else{
          const now = performance.now();
          if (!state.muted && now - state.lastTypeSoundAt > 45){
            AudioEngine.typeClick();
            state.lastTypeSoundAt = now;
          }
        }
      });

      submitBtn.addEventListener("click", onSubmit);

      panicBtn.addEventListener("click", () => {
        flash();
        peekFaces(true);
        if (!state.muted) AudioEngine.fail();
        setCorruption(1);
        feedback.textContent = "–ü–ê–ù–ò–ö–ê: —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–∏–±–ª–∏–∑–∏–ª–∞—Å—å‚Ä¶";
        hintBox.classList.remove("hidden");
        hintBox.textContent = stage.hints[stage.hints.length - 1] || "‚Ä¶";
        penalizeTime(8);
        vibrate(120);
      });

      setTimer(CONFIG.STAGE_TIME[stageId] ?? 90);
      setTimeout(() => input.focus(), 140);

      function onSubmit(){
        const raw = input.value;

        if (!state.muted) AudioEngine.glitch();

        const ok = stage.check(raw);

        if (ok){
          feedback.style.color = "rgba(200,255,220,0.95)";
          feedback.textContent = "‚úÖ –ü—Ä–∏–Ω—è—Ç–æ. –ù–µ –æ–±–æ—Ä–∞—á–∏–≤–∞–π—Å—è.";
          if (!state.muted) AudioEngine.success();
          flash();
          peekFaces(false);
          clearTimer();

          syslog("ACCESS GRANTED ‚ñì‚ñì‚ñì");
          saveGame();

          setTimeout(() => {
            if (stageId === 5) showFinal();
            else goToStage(stageId + 1);
          }, 850);

        }else{
          state.attempts[stageId] = (state.attempts[stageId] ?? 0) + 1;
          const a = state.attempts[stageId];

          feedback.style.color = "rgba(255,200,200,0.95)";
          feedback.textContent = rand([
            "‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –û–Ω —É–ª—ã–±–Ω—É–ª—Å—è.",
            "‚ùå –ù–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑‚Ä¶ –µ—Å–ª–∏ —É—Å–ø–µ–µ—à—å.",
            "‚ùå –û—à–∏–±–∫–∞. –¢–∏—à–∏–Ω–∞ —Å—Ç–∞–ª–∞ –≥—Ä–æ–º—á–µ.",
            "‚ùå –ù–µ–≤–µ—Ä–Ω–æ. –¢—ã –ø–æ—á—É–≤—Å—Ç–≤–æ–≤–∞–ª –≤–∑–≥–ª—è–¥ —Å–±–æ–∫—É."
          ]);

          shake(el.stageCard);
          flash();
          peekFaces(Math.random() < 0.55);
          vibrate(90);

          if (!state.muted) AudioEngine.fail();

          penalizeTime(CONFIG.WRONG_ANSWER_PENALTY_SEC);
          setCorruption(CONFIG.CORRUPTION_PER_WRONG);

          if (a >= CONFIG.HINT_AFTER_ATTEMPTS){
            hintBox.classList.remove("hidden");
            hintBox.textContent = pickHint(stageId, a);
          }

          saveGame();
        }
      }
    }

    function shouldShowHint(stageId, attempts){
      return attempts >= CONFIG.HINT_AFTER_ATTEMPTS;
    }

    function pickHint(stageId, attempts){
      const stage = STAGES.find(s => s.id === stageId);
      if (!stage) return "";
      if (attempts >= CONFIG.STRONG_HINT_AFTER_ATTEMPTS) return stage.hints[1] || stage.hints[0] || "";
      if (attempts >= CONFIG.HINT_AFTER_ATTEMPTS) return stage.hints[0] || "";
      return "";
    }

    function escapeHtml(s){
      return String(s ?? "").replace(/[&<>"']/g, (c) => ({
        "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
      }[c]));
    }

    function goToStage(stageId){
      state.stageId = stageId;
      saveGame();
      syslog("STAGE " + stageId + " LOADED");
      renderStage(stageId);

      // subtle peek on stage change
      if (Math.random() < 0.45) peekFaces(false);
    }

    function onTimeout(){
      clearTimer();
      setCorruption(CONFIG.CORRUPTION_PER_TIMEOUT);
      flash();
      peekFaces(true);
      shake(el.stageCard);
      vibrate(140);
      if (!state.muted) AudioEngine.fail();

      syslog("TIMEOUT ‚ñë‚ñë‚ñë RETRY");
      const back = CONFIG.TIMEOUT_PENALTY_BACK_STAGES;
      const newStage = clamp((state.stageId || 1) - back, 1, 5);

      const fb = $("#feedback");
      if (fb){
        fb.style.color = "rgba(255,200,200,0.95)";
        fb.textContent = "‚è≥ –í—Ä–µ–º—è –≤—ã—à–ª–æ. –û–Ω —Å–¥–µ–ª–∞–ª —à–∞–≥.";
      }

      setTimeout(() => goToStage(newStage), 900);
    }

    function showFinal(){
      state.stageId = 6;
      clearTimer();
      renderProgress(5);

      el.stageCard.classList.add("hidden");
      el.finalCard.classList.remove("hidden");

      syslog("FINAL UNLOCKED ‚ñà‚ñà‚ñà‚ñà‚ñà");
      flash();
      peekFaces(true);
      if (!state.muted) AudioEngine.success();

      if (CONFIG.FINAL_PHOTO_URL && CONFIG.FINAL_PHOTO_URL.trim()){
        el.finalPhoto.src = CONFIG.FINAL_PHOTO_URL.trim();
        el.finalPhoto.style.display = "block";
        el.finalNoPhoto.classList.add("hidden");
      }else{
        el.finalPhoto.style.display = "none";
        el.finalNoPhoto.classList.remove("hidden");
      }

      saveGame();
    }

    /******************************************************************
     * RANDOM FX
     ******************************************************************/
    const RANDOM_LOGS = [
      "packet loss detected ‚Ä¶",
      "unknown process: SANTA.exe",
      "watching‚Ä¶",
      "I can hear you breathe.",
      "clock drift: +00:00:03",
      "permission denied.",
      "do not turn back.",
      "memory leak in sector 31.12",
      "USER FOUND.",
      "he is already here."
    ];

    function startRandomFX(){
      stopRandomFX();
      state.randomFXHandle = setInterval(() => {
        if (!state.started) return;

        if (Math.random() < 0.65) syslog(rand(RANDOM_LOGS));

        if (Math.random() < (CONFIG.RANDOM_GLITCH_CHANCE + (state.corruption/20))){
          if (!state.muted) AudioEngine.glitch();
          if (Math.random() < 0.55) flash();
        }

        // faces peek randomly (very creepy)
        const peekChance = CONFIG.FACE_PEEK_CHANCE + (state.corruption/40);
        if (Math.random() < peekChance){
          const strong = Math.random() < (CONFIG.FACE_PEEK_STRONG_CHANCE + (state.corruption/60));
          peekFaces(strong);
        }

        if (Math.random() < (CONFIG.JUMPSCARE_CHANCE + (state.corruption/40))){
          const fb = $("#feedback");
          if (fb){
            fb.style.color = "rgba(255,200,200,0.95)";
            fb.textContent = rand(["HE IS HERE.", "DON'T LOOK BEHIND YOU.", "RUN.", "TOO LATE."]);
          }
        }
      }, CONFIG.RANDOM_GLITCH_EVERY_MS);
    }

    function stopRandomFX(){
      if (state.randomFXHandle){
        clearInterval(state.randomFXHandle);
        state.randomFXHandle = null;
      }
    }

    /******************************************************************
     * START
     ******************************************************************/
    bindMuteButtons();

    el.startBtn.addEventListener("click", async () => {
      await startExperience();
    });

    el.restartBtn.addEventListener("click", () => {
      clearProgress();
      location.href = location.pathname;
    });

    async function startExperience(){
      if (state.started) return;
      state.started = true;

      el.startOverlay.classList.add("hidden");
      el.app.classList.remove("hidden");

      const restored = restoreGame();
      setMuted(state.muted);

      try{
        await AudioEngine.resume();
        AudioEngine.startBackground();
        await AudioEngine.startMusic(); // <-- –≤–æ—Ç —Ç—É—Ç –º—É–∑—ã–∫–∞/—Å–∞—É–Ω–¥—Ç—Ä–µ–∫
      }catch{}

      syslog("SYSTEM ONLINE");
      startRandomFX();

      if (restored && restored.stageId && restored.stageId >= 1 && restored.stageId <= 5){
        el.introCard.classList.add("hidden");
        goToStage(restored.stageId);
        return;
      }

      if (shouldSkipIntro){
        goToStage(1);
        return;
      }

      await runIntro();
    }

    window.addEventListener("beforeunload", () => {
      saveGame();
    });
  </script>
</body>
</html>
